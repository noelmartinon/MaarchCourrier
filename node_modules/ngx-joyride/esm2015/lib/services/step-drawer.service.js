import { __decorate } from "tslib";
import { Injectable, ComponentRef, ComponentFactoryResolver, ApplicationRef, Injector, EmbeddedViewRef } from '@angular/core';
import { JoyrideStepComponent } from '../components';
let StepDrawerService = class StepDrawerService {
    constructor(componentFactoryResolver, appRef, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.injector = injector;
        this.refMap = {};
    }
    draw(step) {
        // 1. Create a component reference from the component
        const ref = this.componentFactoryResolver
            .resolveComponentFactory(JoyrideStepComponent)
            .create(this.injector);
        // 2. Attach component to the appRef so that it's inside the ng component tree
        this.appRef.attachView(ref.hostView);
        // 3. Get DOM element from component
        const domElem = ref.hostView
            .rootNodes[0];
        // 4. Append DOM element to the body
        document.body.appendChild(domElem);
        const instance = ref.instance;
        instance.step = step;
        ref.changeDetectorRef.detectChanges();
        step.stepInstance = instance;
        this.refMap[step.name] = ref;
    }
    remove(step) {
        this.appRef.detachView(this.refMap[step.name].hostView);
        this.refMap[step.name].destroy();
    }
};
StepDrawerService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector }
];
StepDrawerService = __decorate([
    Injectable()
], StepDrawerService);
export { StepDrawerService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcC1kcmF3ZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1qb3lyaWRlLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL3N0ZXAtZHJhd2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCxVQUFVLEVBQ1YsWUFBWSxFQUNaLHdCQUF3QixFQUN4QixjQUFjLEVBQ2QsUUFBUSxFQUNSLGVBQWUsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBSXJELElBQWEsaUJBQWlCLEdBQTlCLE1BQWEsaUJBQWlCO0lBRzFCLFlBQ3FCLHdCQUFrRCxFQUMzRCxNQUFzQixFQUN0QixRQUFrQjtRQUZULDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7UUFDM0QsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFDdEIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUx0QixXQUFNLEdBQTBELEVBQUUsQ0FBQztJQU14RSxDQUFDO0lBRUosSUFBSSxDQUFDLElBQWlCO1FBQ2xCLHFEQUFxRDtRQUNyRCxNQUFNLEdBQUcsR0FBdUMsSUFBSSxDQUFDLHdCQUF3QjthQUN4RSx1QkFBdUIsQ0FBQyxvQkFBb0IsQ0FBQzthQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTNCLDhFQUE4RTtRQUM5RSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFckMsb0NBQW9DO1FBQ3BDLE1BQU0sT0FBTyxHQUFJLEdBQUcsQ0FBQyxRQUFpQzthQUNqRCxTQUFTLENBQUMsQ0FBQyxDQUFnQixDQUFDO1FBRWpDLG9DQUFvQztRQUNwQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVuQyxNQUFNLFFBQVEsR0FBeUIsR0FBRyxDQUFDLFFBQVEsQ0FBQztRQUNwRCxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNyQixHQUFHLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUM7UUFFN0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxNQUFNLENBQUMsSUFBaUI7UUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDckMsQ0FBQztDQUNKLENBQUE7O1lBakNrRCx3QkFBd0I7WUFDbkQsY0FBYztZQUNaLFFBQVE7O0FBTnJCLGlCQUFpQjtJQUQ3QixVQUFVLEVBQUU7R0FDQSxpQkFBaUIsQ0FxQzdCO1NBckNZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgSW5qZWN0YWJsZSxcbiAgICBDb21wb25lbnRSZWYsXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIEFwcGxpY2F0aW9uUmVmLFxuICAgIEluamVjdG9yLFxuICAgIEVtYmVkZGVkVmlld1JlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEpveXJpZGVTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cyc7XG5pbXBvcnQgeyBKb3lyaWRlU3RlcCB9IGZyb20gJy4uL21vZGVscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGVwRHJhd2VyU2VydmljZSB7XG4gICAgcHJpdmF0ZSByZWZNYXA6IHsgW2tleTogc3RyaW5nXTogQ29tcG9uZW50UmVmPEpveXJpZGVTdGVwQ29tcG9uZW50PiB9ID0ge307XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHJpdmF0ZSBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmLFxuICAgICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvclxuICAgICkge31cblxuICAgIGRyYXcoc3RlcDogSm95cmlkZVN0ZXApIHtcbiAgICAgICAgLy8gMS4gQ3JlYXRlIGEgY29tcG9uZW50IHJlZmVyZW5jZSBmcm9tIHRoZSBjb21wb25lbnRcbiAgICAgICAgY29uc3QgcmVmOiBDb21wb25lbnRSZWY8Sm95cmlkZVN0ZXBDb21wb25lbnQ+ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShKb3lyaWRlU3RlcENvbXBvbmVudClcbiAgICAgICAgICAgIC5jcmVhdGUodGhpcy5pbmplY3Rvcik7XG5cbiAgICAgICAgLy8gMi4gQXR0YWNoIGNvbXBvbmVudCB0byB0aGUgYXBwUmVmIHNvIHRoYXQgaXQncyBpbnNpZGUgdGhlIG5nIGNvbXBvbmVudCB0cmVlXG4gICAgICAgIHRoaXMuYXBwUmVmLmF0dGFjaFZpZXcocmVmLmhvc3RWaWV3KTtcblxuICAgICAgICAvLyAzLiBHZXQgRE9NIGVsZW1lbnQgZnJvbSBjb21wb25lbnRcbiAgICAgICAgY29uc3QgZG9tRWxlbSA9IChyZWYuaG9zdFZpZXcgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT4pXG4gICAgICAgICAgICAucm9vdE5vZGVzWzBdIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIC8vIDQuIEFwcGVuZCBET00gZWxlbWVudCB0byB0aGUgYm9keVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvbUVsZW0pO1xuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlOiBKb3lyaWRlU3RlcENvbXBvbmVudCA9IHJlZi5pbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2Uuc3RlcCA9IHN0ZXA7XG4gICAgICAgIHJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHN0ZXAuc3RlcEluc3RhbmNlID0gaW5zdGFuY2U7XG5cbiAgICAgICAgdGhpcy5yZWZNYXBbc3RlcC5uYW1lXSA9IHJlZjtcbiAgICB9XG5cbiAgICByZW1vdmUoc3RlcDogSm95cmlkZVN0ZXApIHtcbiAgICAgICAgdGhpcy5hcHBSZWYuZGV0YWNoVmlldyh0aGlzLnJlZk1hcFtzdGVwLm5hbWVdLmhvc3RWaWV3KTtcbiAgICAgICAgdGhpcy5yZWZNYXBbc3RlcC5uYW1lXS5kZXN0cm95KCk7XG4gICAgfVxufVxuIl19